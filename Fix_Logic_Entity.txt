--[[
    Vynixu Entity Spawner V2 - FIXED (Anti-WallClip & Smart Avoidance)
]]--

if VynixuEntitySpawnerV2 then return VynixuEntitySpawnerV2 end

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Variables
local localPlayer = Players.LocalPlayer
local localChar = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local localHum = localChar:WaitForChild("Humanoid")
local localCollision = localChar:WaitForChild("Collision")
local localCamera = workspace.CurrentCamera
local playerGui = localPlayer:WaitForChild("PlayerGui")
local gameStats = ReplicatedStorage:WaitForChild("GameStats")
local gameData = ReplicatedStorage:WaitForChild("GameData")
local floorReplicated = ReplicatedStorage:WaitForChild("FloorReplicated")
local remotesFolder = ReplicatedStorage:WaitForChild("RemotesFolder")

local lastRespawn;
local BaseEntitySpeed = 65

local vynixuModules = {
	Functions = loadstring(game:HttpGet("https://raw.githubusercontent.com/RegularVynixu/Utilities/main/Functions.lua"))()
}
local assets = {
	Repentance = LoadCustomInstance("https://github.com/RegularVynixu/Utilities/blob/main/Doors/Entity%20Spawner/Assets/Repentance.rbxm?raw=true")
}
local moduleScripts = {
	Module_Events = require(ReplicatedStorage.ModulesClient.Module_Events),
	Main_Game = require(playerGui.MainUI.Initiator.Main_Game),
	Earthquake = require(remotesFolder.RequestAsset:InvokeServer("Earthquake"))
}

local defaultEntityAttributes = { Running = false, CustomEntity = true, Paused = false, BeingBanished = false, Despawning = false, Damage = true, LastEnteredRoom = -1 }
local defaultPlayerAttributes = { SpawnProtection = 5 }
local defaultDebug = { OnSpawned = function() end, OnStartMoving = function() end, OnReachedNode = function() end, OnEnterRoom = function() end, OnLookAt = function() end, OnRebounding = function() end, OnDespawning = function() end, OnDespawned = function() end, OnDamagePlayer = function() end, CrucifixionOverwrite = "" }
local defaultConfig = {
	Entity = { Name = "Template Entity", Asset = "https://github.com/RegularVynixu/Utilities/blob/main/Doors%20Entity%20Spawner/Models/Rush.rbxm?raw=true", HeightOffset = 0 },
	Movement = { Speed = 100, Delay = 2, Reversed = false },
	Damage = { Enabled = true, Range = 40, Amount = 125 },
	Rebounding = { Enabled = true, Type = "Ambush", Min = 2, Max = 4, Delay = 2 },
	Lights = { Flicker = { Enabled = true, Duration = 1 }, Shatter = true, Repair = false },
	Earthquake = { Enabled = true },
	CameraShake = { Enabled = true, Values = {1.5, 20, 0.1, 1}, Range = 100 },
	Crucifixion = { Type = "Curious", Enabled = true, Range = 40, Resist = false, Break = true },
	Death = { Type = "Guiding", Hints = {"Death", "Hints", "Go", "Here"}, Cause = "" }
}
local ambientStorage = {}
local deathTypes = { ["Yellow"] = {"yellow", "curious"}, ["Blue"] = {"blue", "guiding"} }
local spawner = {}

-- Helper Functions
function CloneTable(tbl)
    local cloned = {}
    for key, value in pairs(tbl) do
        if typeof(value) == "table" then cloned[key] = CloneTable(value) else cloned[key] = value end
    end
    return cloned
end

function OnCharacterAdded(char)
	lastRespawn = tick()
	localChar = char
	localHum = char:WaitForChild("Humanoid")
	localCollision = char:WaitForChild("Collision")
end

function GetCurrentRoom(latest)
    if latest then return workspace.CurrentRooms:GetChildren()[#workspace.CurrentRooms:GetChildren()] end
    return workspace.CurrentRooms:FindFirstChild(localPlayer:GetAttribute("CurrentRoom"))
end

function GetNodesFromRoom(room, reversed)
	local nodes = {}
	local roomEntrance = room:FindFirstChild("RoomEntrance")
	if roomEntrance then
		local n = roomEntrance:Clone()
		n.Name = "0"
		n.CFrame -= Vector3.new(0, 3, 0)
		nodes[1] = n
	end
	local nodesFolder = room:FindFirstChild("PathfindNodes")
	if nodesFolder then for _, n in nodesFolder:GetChildren() do nodes[#nodes + 1] = n end end
	local roomExit = room:FindFirstChild("RoomExit")
	if roomExit then
		local index = #nodes + 1
		local n = roomExit:Clone()
		n.Name = index
		n.CFrame -= Vector3.new(0, 3, 0)
		nodes[index] = n
	end
	table.sort(nodes, function(a, b)
		if reversed then return tonumber(a.Name) > tonumber(b.Name) else return tonumber(a.Name) < tonumber(b.Name) end
	end)
	return nodes
end

function GetPathfindNodesAmbush(config)
	local pathfindNodes = {}
    local rooms = workspace.CurrentRooms:GetChildren()
    if config.Movement.Reversed == false then
        for i = 1, #rooms, 1 do
            local room = rooms[i]
            local roomNodes = GetNodesFromRoom(room, false)
            for _, node in roomNodes do pathfindNodes[#pathfindNodes + 1] = node end
        end
    else
        for i = #rooms, 1, -1 do
            local room = rooms[i]
            local roomNodes = GetNodesFromRoom(room, true)
            for _, node in roomNodes do pathfindNodes[#pathfindNodes + 1] = node end
        end
    end
	return pathfindNodes
end

function GetPathfindNodesBlitz(config)
	local nodesToCurrent, nodesToEnd = {}, {}
	local currentRoomIndex = localPlayer:GetAttribute("CurrentRoom")
    local rooms = workspace.CurrentRooms:GetChildren()
    if config.Movement.Reversed == false then
        for _, room in rooms do
            local roomNodes = GetNodesFromRoom(room, false)
            local roomIndex = tonumber(room.Name)
            for _, node in roomNodes do
                if roomIndex <= currentRoomIndex then nodesToCurrent[#nodesToCurrent + 1] = node else nodesToEnd[#nodesToEnd + 1] = node end
            end
        end
    else
        for i = #rooms, 1, -1 do
            local room = rooms[i]
            local roomNodes = GetNodesFromRoom(room, true)
            local roomIndex = tonumber(room.Name)
            for _, node in roomNodes do
                if roomIndex >= currentRoomIndex then nodesToCurrent[#nodesToCurrent + 1] = node else nodesToEnd[#nodesToEnd + 1] = node end
            end
        end 
    end
	return nodesToCurrent, nodesToEnd
end

function PlayerInLineOfSight(model, config)
	local origin = model:GetPivot().Position
	local charOrigin = localCollision.Position
	if (charOrigin - origin).Magnitude <= config.Damage.Range then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {localChar, model}
		local result = workspace:Raycast(origin, charOrigin - origin, params)
		return (result == nil), result
	end
	return false
end

function PlayerHasItemEquipped(name)
	local tool = localChar:FindFirstChildOfClass("Tool")
	return tool and tool.Name == name, tool
end

-- FIXED CORE FUNCTION: EntityMoveTo
function EntityMoveTo(model, targetCFrame, speed)
    local reached = false
    local connection;
    
    connection = RunService.Stepped:Connect(function(_, step)
        if not model or not model.Parent or reached then 
            if connection then connection:Disconnect() end
            return 
        end
        
        if not model:GetAttribute("Paused") then
            local currentPivot = model:GetPivot()
            local targetPos = targetCFrame.Position
            local diff = (targetPos - currentPivot.Position)
            local dist = diff.Magnitude
            
            if dist > 0.1 then
                local moveDir = diff.Unit
                local moveStep = math.min(dist, step * speed)
                
                -- Raycast dò vật cản
                local rayParams = RaycastParams.new()
                rayParams.FilterDescendantsInstances = {model, localChar, workspace.CurrentCamera}
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                
                local rayResult = workspace:Raycast(currentPivot.Position, moveDir * 5, rayParams)
                
                local finalMovePos = currentPivot.Position + (moveDir * moveStep)
                
                if rayResult and rayResult.Instance and rayResult.Instance.CanCollide then
                    -- Né sang bên nếu gặp tường
                    local lateralDir = Vector3.new(-moveDir.Z, 0, moveDir.X).Unit
                    finalMovePos = currentPivot.Position + (moveDir + lateralDir * 1.5).Unit * moveStep
                end
                
                model:PivotTo(CFrame.new(finalMovePos, finalMovePos + moveDir))
            else
                reached = true
                if connection then connection:Disconnect() end
            end
        end
    end)
    
    while not reached and model and model.Parent do task.wait() end
end

-- (Các hàm DamagePlayer, FixRoomLights... giữ nguyên như bản gốc của bạn)
function PlayerIsProtected() return (tick() - lastRespawn) <= localPlayer:GetAttribute("SpawnProtection") end

function DamagePlayer(entityTable)
	if localHum.Health > 0 and not PlayerIsProtected() then
		local config = entityTable.Config
		local newHealth = math.clamp(localHum.Health - config.Damage.Amount, 0, localHum.MaxHealth)
		if newHealth == 0 then
			local deathCause = config.Entity.Name
			if config.Death.Cause ~= "" then deathCause = config.Death.Cause end
			gameStats["Player_".. localPlayer.Name].Total.DeathCause.Value = deathCause
		end
		localHum.Health = newHealth
		task.spawn(entityTable.RunCallback, entityTable, "OnDamagePlayer", newHealth)
	end
end

function GetRoomAtPoint(vector3)
	local whitelist = {}
	for _, room in workspace.CurrentRooms:GetChildren() do
		local p = room:FindFirstChild(room.Name)
		if p then whitelist[#whitelist + 1] = p end
	end
	if #whitelist > 0 then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = whitelist
		params.CollisionGroup = "BaseCheck"
		local result = workspace:Raycast(vector3, Vector3.new(0, -100, 0), params)
		if result then
			for _, room in workspace.CurrentRooms:GetChildren() do
				if result.Instance.Parent == room then return room end
			end
		end
	end
end

function ApplyConfigDefaults(tbl, defaults)
    for key, value in defaults do
		if tbl[key] == nil then tbl[key] = value
        elseif typeof(value) == "table" then
            if not tbl[key] or typeof(tbl[key]) ~= "table" then tbl[key] = {} end
            ApplyConfigDefaults(tbl[key], value)
        end
    end
end

spawner.Create = function(config)
	ApplyConfigDefaults(config, defaultConfig)
	config.Movement.Speed = BaseEntitySpeed / 100 * config.Movement.Speed
	local asset = config.Entity.Asset
	local success, entityModel;
	if typeof(asset) == "Instance" and asset:IsA("Model") then success, entityModel = true, asset
	elseif typeof(asset) == "string" then
		success, entityModel = pcall(function() return LoadCustomInstance(asset) end)
	end
	if success and entityModel then
		local root = entityModel.PrimaryPart or entityModel:FindFirstChildWhichIsA("BasePart")
		if root then
			root.Anchored = true
			entityModel.PrimaryPart = root
			if config.Entity.Name ~= "" then entityModel.Name = config.Entity.Name end
			for name, value in defaultEntityAttributes do entityModel:SetAttribute(name, value) end
		end
		local entityTable = {
			Model = entityModel, Config = config, Debug = CloneTable(defaultDebug),
			Pause = function(self, bool) if self.Model then self.Model:SetAttribute("Paused", bool) end end,
			Despawn = function(self) if self.Model then self.Model:Destroy(); self.Model = nil end end,
			RunCallback = function(self, key, ...) if self.Debug[key] then pcall(self.Debug[key], ...) end end
		}
		entityTable.Run = function(self) spawner.Run(self) end
		return entityTable
	end
end

spawner.Run = function(entityTable)
	task.spawn(function()
		local model = entityTable.Model
		local config = entityTable.Config
		model:SetAttribute("Running", true)
		local spawnPoint;
		local rooms = workspace.CurrentRooms:GetChildren()
		spawnPoint = config.Movement.Reversed and rooms[#rooms]:FindFirstChild("RoomExit") or rooms[1]:FindFirstChild("RoomEntrance")
		
		if spawnPoint then
			model:PivotTo(spawnPoint.CFrame + Vector3.new(0, config.Entity.HeightOffset, 0))
			model.Parent = workspace
            
			task.wait(config.Movement.Delay)
			
			-- Bắt đầu di chuyển
			task.spawn(function()
				local pathfindNodes = GetPathfindNodesAmbush(config)
				for _, n in pathfindNodes do
					EntityMoveTo(model, n.CFrame + Vector3.new(0, 3 + config.Entity.HeightOffset, 0), config.Movement.Speed)
				end
				-- Despawn
				entityTable:Despawn()
			end)
		end
	end)
end

localPlayer.CharacterAdded:Connect(OnCharacterAdded)
return spawner
